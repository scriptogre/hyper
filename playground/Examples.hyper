user: dict
items: list
count: int = 0
is_active: bool = True


# Simple if
if is_active:
    <span>Active</span>
end

# if/else
if count > 0:
    <span>Has items</span>
else:
    <span>No items</span>
end

# if/elif/else chain
if count == 0:
    <span class="empty">
        Chrispy
    </span>
elif count == 1:
    <span class="single">
        One item
    </span>
elif count < 10:
    <span class="few">
        A few items {count}
    </span>
else:
    <span class="many">Many items</span>
end

# Simple for loop
<ul>
    for item in items:
        <li>{item}</li>
    end
</ul>

# Nested for loops
<table>
    for row in user['rows']:
        <tr>
            for cell in row:
                <td>{cell}</td>
            end
        </tr>
    end
</table>

# While loop
while count < 10:
    <span>{count}</span>
    count = count + 1
end

# Match/case
match user['status']:
    case "active":
        <span class="green">Active</span>
    case "pending":
        <span class="yellow">Pending</span>
    case "inactive":
        <span class="red">Inactive</span>
    case _:
        <span class="gray">Unknown</span>
end

# Function definition
def greet(name: str):
    <h1>Hello, {name}!</h1>
end

# Function with multiple statements
def render_card(user: dict, show_details: bool):
    <div class="card">
        <h2>{user['name']}</h2>
        if show_details:
            <p>{user['bio']}</p>
            for tag in user['tags']:
                <span class="tag">{tag}</span>
            end
        end
    </div>
end

# Deeply nested structure
<div class="container">
    if is_active:
        <div class="content">
            for section in user['sections']:
                <section>
                    if section['visible']:
                        match section['type']:
                            case "header":
                                <h2>{section['title']}</h2>
                            case "paragraph":
                                <p>{section['content']}</p>
                            case "list":
                                <ul>
                                    for item in section['items']:
                                        <li>{item}</li>
                                    end
                                </ul>
                        end
                    else:
                        <span class="hidden">Hidden section</span>
                    end
                </section>
            end
        </div>
    end
</div>

# Comments and Python code mixed with HTML
total = 0
for item in items:
    # Calculate running total
    total = total + item['price']
    <div class="item">
        <span class="name">{item['name']}</span>
        <span class="price">${item['price']}</span>
    </div>
end
<div class="total">Total: ${total}</div>

# ============================================
# ADDITIONAL TEST SCENARIOS
# ============================================

# Multiple expressions on one line
<p>{user['first']} {user['last']} ({user['age']} years old)</p>

# Expressions in attributes
<div class="{user['theme']}" id="user-{user['id']}" data-count="{count}">
    <span style="color: {user['color']}">
        Styled text
    </span>
</div>

# Complex expressions
<span>{user['name'].upper()}</span>
<span>{", ".join(items)}</span>
<span>{len(items)} items</span>
<span>{items[0] if items else "empty"}</span>

# Nested dict access in expressions
<p>{user['address']['city']}, {user['address']['country']}</p>

# Method chaining
<p>{user['bio'].strip().capitalize()}</p>

# Arithmetic in expressions
<span>Total: {count * 10 + 5}</span>
<span>Average: {total / len(items) if items else 0}</span>

# Boolean expressions
<span>{is_active and "Yes" or "No"}</span>
<span>{"Active" if is_active else "Inactive"}</span>

# List/dict comprehension in expressions
<span>{[x * 2 for x in range(5)]}</span>
<span>{{ k: v.upper() for k, v in user.items() if isinstance(v, str) }}</span>

# Nested braces (dict literal inside expression)
data = {"key": "value", "nested": {"a": 1}}
<span>{data}</span>

# F-string style with format specs
<span>{user['score']:.2f}</span>
<span>{count:03d}</span>
<span>{user['name']:>20}</span>

# Self-closing HTML tags
<img src="{user['avatar']}" alt="{user['name']}" />
<br />
<input type="text" value="{user['name']}" />
<hr />

# HTML with nested quotes (JSON needs escaped braces)
<div data-json='{{"name": "{user["name"]}"}}'></div>
<a href="/user/{user['id']}" title='View {user["name"]}'>Link</a>

# Empty control blocks (generates pass)
if False:
end

for x in []:
end

# Consecutive HTML lines (no Python between)
<header>
    <nav>
        <ul>
            <li><a href="/">Home</a></li>
            <li><a href="/about">About</a></li>
            <li><a href="/contact">Contact</a></li>
        </ul>
    </nav>
</header>

# HTML with special characters and entities
<p>&lt;script&gt; is escaped</p>
<p>Copyright &copy; 2024</p>
<p>Price: &euro;{count}</p>

# Mixed indentation scenarios
if is_active:
    <div>
        Level 1
        if count > 0:
            <div>
                Level 2
                for i in range(count):
                    <span>Level 3: {i}</span>
                end
            </div>
        end
    </div>
end

# Inline conditionals in HTML context
<div class="card {'active' if is_active else 'inactive'} {'premium' if count > 100 else 'basic'}">
    Content
</div>

# Function with default parameter
def badge(text: str, color: str = "blue"):
    <span class="badge badge-{color}">{text}</span>
end

# Function returning after HTML
def get_status_html(status: str):
    match status:
        case "ok":
            <span class="green">OK</span>
        case "error":
            <span class="red">Error</span>
        case _:
            <span class="gray">Unknown</span>
    end
end

# Class definition
class Card:
    def __init__(self, title: str):
        self.title = title
    end

    def render(self):
        <div class="card">
            <h3>{self.title}</h3>
        </div>
    end
end

# Lambda in expression
sorter = lambda x: x['name']
sorted_items = sorted(items, key=sorter)
for item in sorted_items:
    <li>{item['name']}</li>
end

# Walrus operator
if (n := len(items)) > 0:
    <p>Found {n} items</p>
end

# Unpacking in for loop
pairs = [("a", 1), ("b", 2), ("c", 3)]
for key, value in pairs:
    <dt>{key}</dt>
    <dd>{value}</dd>
end

# Enumerate
for i, item in enumerate(items):
    <li data-index="{i}">{item}</li>
end

# Zip
names = ["Alice", "Bob"]
scores = [100, 95]
for name, score in zip(names, scores):
    <tr><td>{name}</td><td>{score}</td></tr>
end

# Slice expressions
<span>First three: {items[:3]}</span>
<span>Last two: {items[-2:]}</span>
<span>Every other: {items[::2]}</span>

# Complex nested match
match user:
    case {"type": "admin", "level": level}:
        <span class="admin">Admin Level {level}</span>
    case {"type": "user", "verified": True}:
        <span class="verified">Verified User</span>
    case {"type": "user", "verified": False}:
        <span class="unverified">Unverified User</span>
    case _:
        <span>Guest</span>
end

# Expression with getattr/hasattr
<span>{getattr(user, 'name', 'Anonymous')}</span>

# Multi-line HTML tag - put on single line (multi-line not supported)
<div class="container {user['theme']}" id="main-{user['id']}" data-active="{is_active}">
    <p>Multi-line tag content</p>
</div>

# Raw Python blocks between HTML
<section>
result = []
for i in range(5):
    result.append(i ** 2)
end
squares = result
</section>
<ul>
    for sq in squares:
        <li>{sq}</li>
    end
</ul>

# Comments interspersed
<div>
    # This is a comment inside HTML context
    <p>Paragraph 1</p>
    # Another comment
    <p>Paragraph 2</p>
</div>

# Escape sequences in strings
message = "Hello\nWorld"
<pre>{message}</pre>

# Unicode in expressions
<span>{'‚òÖ' * count}</span>
<span>{user.get('emoji', 'üë§')}</span>

# Chained comparisons
if count > 0 and count < 100:
    <span>In range</span>
end

# Not operator
if not is_active:
    <span>Inactive</span>
end

# In operator
if "admin" in user.get('roles', []):
    <span class="admin-badge">Admin</span>
end

# Try/except (if supported)
try:
    <span>{risky_operation()}</span>
except:
    <span>Error occurred</span>
end

# Generator expression
<span>{sum(x for x in range(10))}</span>
<span>{",".join(str(x) for x in items)}</span>

# Nested ternary
<span>{"many" if count > 10 else "few" if count > 0 else "none"}</span>

# HTML inside string (edge case - should be treated as Python)
html_string = "<div>Not actual HTML</div>"
<p>{html_string}</p>

# Very long expression
<p>{user['profile']['settings']['preferences']['theme']['primary_color'] if user.get('profile') and user['profile'].get('settings') else 'default'}</p>

# ============================================
# CSS / STYLE SCENARIOS
# ============================================

# Inline styles with Python expressions
<div style="color: {user['color']}; font-size: {count}px;">Styled</div>
<div style="background: rgb({user['r']}, {user['g']}, {user['b']});">RGB</div>

# CSS custom properties
<div style="--primary-color: {user['theme_color']}; color: var(--primary-color);">Custom prop</div>

# CSS calc (braces in CSS don't interfere)
<div style="width: calc(100% - {count}px);">Calc</div>

# Style block (CSS braces should be preserved)
<style>
    .card {{ background: white; }}
    .card:hover {{ transform: scale(1.05); }}
    @media (max-width: 768px) {{
        .card {{ padding: 10px; }}
    }}
    @keyframes fade {{
        from {{ opacity: 0; }}
        to {{ opacity: 1; }}
    }}
</style>

# ============================================
# JAVASCRIPT SCENARIOS
# ============================================

# Script block with JS (keep on single lines that start with < or use inline)
<script>const data = {{ name: "{user['name']}", count: {count} }}; console.log(data);</script>

# Or use type=module with src for external JS
<script type="module" src="/js/app.js" data-user-id="{user['id']}"></script>

# Inline event handlers
<button onclick="alert('Count: {count}')">Alert</button>
<button onclick="console.log({{ id: {user['id']} }})">Log</button>

# ============================================
# ALPINE.JS SCENARIOS
# ============================================

# Alpine x-data with object literal (double braces to escape)
<div x-data="{{ open: false, count: {count} }}">
    <button @click="open = !open">Toggle</button>
    <div x-show="open">Content</div>
</div>

# Alpine x-for (looks like Python for, but it's Alpine)
<template x-for="item in items">
    <div x-text="item"></div>
</template>

# Alpine with Python data injected
<div x-data="{{ items: {items}, user: {user} }}">
    <template x-for="item in items">
        <span x-text="item.name"></span>
    </template>
</div>

# Alpine shorthand bindings
<div :class="{{ 'active': isActive, 'disabled': !isActive }}">Bound</div>
<input :value="count" @input="count = $event.target.value" />

# Alpine x-bind with Python expression
<div x-bind:class="count > 0 ? 'has-items' : 'empty'" data-count="{count}">
    Alpine conditional class
</div>

# ============================================
# HTMX SCENARIOS
# ============================================

# HTMX attributes
<button hx-get="/api/items" hx-target="#list" hx-swap="innerHTML">Load</button>
<div hx-post="/api/items/{user['id']}" hx-trigger="click" hx-vals='{{"count": {count}}}'>
    HTMX with Python data
</div>

# HTMX with dynamic URLs
<a hx-get="/users/{user['id']}/profile" hx-push-url="true">View Profile</a>

# ============================================
# SVG SCENARIOS
# ============================================

# SVG with Python expressions
<svg width="{count * 10}" height="100" viewBox="0 0 100 100">
    <circle cx="50" cy="50" r="{count}" fill="{user['color']}" />
    <text x="50" y="50" text-anchor="middle">{user['name']}</text>
    <path d="M 10 10 L {count} {count}" stroke="black" />
</svg>

# SVG with style
<svg>
    <style>
        .highlight {{ fill: yellow; }}
    </style>
    <rect class="highlight" width="{count}" height="50" />
</svg>

# ============================================
# SPECIAL HTML SCENARIOS
# ============================================

# Pre/code blocks (content that looks like Python needs escaping or single-line)
<pre><code>function example() {{ return {count}; }}</code></pre>

# HTML comments (should be preserved)
<!-- User: {user['name']} -->
<div>
    <!-- TODO: Add more content -->
    Content here
</div>

# Data attributes with JSON
<div data-config='{{"id": {user["id"]}, "name": "{user["name"]}"}}'>Config</div>
<div data-items='{items}'>Items as JSON</div>

# Boolean attributes
<input type="checkbox" {"checked" if is_active else ""} />
<button {"disabled" if count == 0 else ""}>Submit</button>

# Custom elements / Web Components
<my-card user-id="{user['id']}" theme="{user['theme']}">
    <slot name="header">{user['name']}</slot>
</my-card>

# Template tag
<template id="card-template">
    <div class="card">
        <h3>{user['name']}</h3>
    </div>
</template>

# Iframe with srcdoc
<iframe srcdoc="<html><body><h1>{user['name']}</h1></body></html>"></iframe>

# ============================================
# ESCAPING EDGE CASES
# ============================================

# Literal braces (doubled to escape)
<p>Use {{variable}} for templates</p>
<p>JSON example: {{"key": "value"}}</p>

# HTML entities for braces
<p>Opening brace: &#123; Closing: &#125;</p>

# Mixed escaped and unescaped
<p>Static {{braces}} and dynamic {count}</p>

# Triple braces edge case
<p>{{{user['name']}}}</p>

# ============================================
# TAILWIND CSS SCENARIOS
# ============================================

# Long Tailwind class strings
<div class="flex items-center justify-between p-4 bg-white dark:bg-gray-800 rounded-lg shadow-md hover:shadow-lg transition-shadow duration-200 {user['extra_classes']}">
    <span class="text-lg font-semibold text-gray-900 dark:text-white">{user['name']}</span>
    <span class="px-2 py-1 text-sm {'bg-green-100 text-green-800' if is_active else 'bg-red-100 text-red-800'} rounded-full">
        {'Active' if is_active else 'Inactive'}
    </span>
</div>

# Tailwind with conditional classes
<div class="btn {'btn-primary' if user['role'] == 'admin' else 'btn-secondary'} {'btn-lg' if count > 10 else 'btn-sm'}">
    Button
</div>

# ============================================
# EDGE CASE EXPRESSIONS
# ============================================

# Nested quotes in expressions
<div title='{user["name"]} said "hello"'>Quotes</div>
<div data-msg="{user['message'].replace('"', '&quot;')}">Escaped quotes</div>

# Backslashes (must use variable - backslash not allowed in f-string expr)
path_normalized = user['path'].replace('\\', '/')
<div data-path="{path_normalized}">Path</div>

# Newlines in expressions (use chr() or variable)
newline = "\n"
<pre>{newline.join(items)}</pre>

# Raw strings (backslash limitation - use variable)
raw_text = r"\n is a newline"
<p>{raw_text}</p>

# Bytes (edge case)
<p>{user.get('data', b'').decode('utf-8')}</p>

# Complex dict/list literals mixed with expressions
config = {"theme": user['theme'], "count": count, "items": [x for x in items if x]}
<div data-config="{config}">Complex config</div>

# Walrus in comprehension
<ul>
    for item in [y for x in items if (y := x.strip())]:
        <li>{item}</li>
    end
</ul>

# ============================================
# INTERNATIONALIZATION
# ============================================

# RTL text
<div dir="rtl" lang="ar">{user.get('arabic_name', 'ŸÖÿ±ÿ≠ÿ®ÿß')}</div>

# Unicode normalization
<p>{user['name'].encode('utf-8').decode('utf-8')}</p>

# Emoji in content and attributes
<span title="{user.get('mood', 'üòä')}">{user.get('emoji', 'üë§')} {user['name']}</span>

# CJK characters
<p lang="ja">{user.get('japanese_name', '„Åì„Çì„Å´„Å°„ÅØ')}</p>

# ============================================
# FORM SCENARIOS
# ============================================

# Form with dynamic action
<form action="/users/{user['id']}/update" method="POST">
    <input type="hidden" name="csrf" value="{user.get('csrf_token', '')}" />
    <input type="text" name="name" value="{user['name']}" placeholder="Name" />
    <select name="role">
        for role in ['user', 'admin', 'guest']:
            <option value="{role}" {"selected" if role == user.get('role') else ""}>{role.title()}</option>
        end
    </select>
    <textarea name="bio">{user.get('bio', '')}</textarea>
    <button type="submit">Save</button>
</form>

# Input with datalist
<input list="suggestions" value="{user.get('search', '')}" />
<datalist id="suggestions">
    for suggestion in items[:5]:
        <option value="{suggestion}">
    end
</datalist>

# ============================================
# TABLE SCENARIOS
# ============================================

# Complex table with all features
<table class="w-full">
    <caption>{user['name']}'s Data ({len(items)} items)</caption>
    <thead>
        <tr>
            <th scope="col">#</th>
            <th scope="col">Name</th>
            <th scope="col">Value</th>
        </tr>
    </thead>
    <tbody>
        for i, item in enumerate(items):
            <tr class="{'bg-gray-100' if i % 2 == 0 else 'bg-white'}">
                <td>{i + 1}</td>
                <td>{item.get('name', 'N/A')}</td>
                <td>{item.get('value', 0):.2f}</td>
            </tr>
        end
    </tbody>
    <tfoot>
        <tr>
            <td colspan="2">Total</td>
            <td>{sum(item.get('value', 0) for item in items):.2f}</td>
        </tr>
    </tfoot>
</table>

# ============================================
# ACCESSIBILITY SCENARIOS
# ============================================

# ARIA attributes
<div role="alert" aria-live="polite" aria-label="{user['name']} notification">
    <span aria-hidden="true">‚ö†Ô∏è</span>
    {user.get('alert_message', 'No alerts')}
</div>

# Skip links and landmarks
<a href="#main-content" class="sr-only focus:not-sr-only">Skip to content</a>
<main id="main-content" role="main" aria-labelledby="heading-{user['id']}">
    <h1 id="heading-{user['id']}">{user['name']}</h1>
</main>

# ============================================
# ASSIGNING HTML TO VARIABLES
# ============================================

# Sub-component function returns HTML that can be stored
def make_badge(text: str, color: str = "blue"):
    <span class="badge badge-{color}">{text}</span>
end

# Call sub-component and use its result
admin_badge = make_badge("Admin", "red")
user_badge = make_badge("User", "green")

<div class="badges">
    {admin_badge}
    {user_badge}
    {make_badge("Guest", "gray")}
</div>

# Conditionally build HTML and assign to variable
def render_status(status: str):
    if status == "online":
        <span class="status online">‚óè</span>
    elif status == "away":
        <span class="status away">‚óê</span>
    else:
        <span class="status offline">‚óã</span>
    end
end

status_html = render_status(user.get("status", "offline"))
<div class="user-status">{status_html}</div>

# Build a list of HTML fragments
def render_tag(tag: str):
    <span class="tag">{tag}</span>
end

tags_html = [render_tag(t) for t in user.get("tags", [])]
<div class="tag-list">
    for tag_html in tags_html:
        {tag_html}
    end
</div>

# ============================================
# NEW ATTRIBUTE FEATURES (compile-time)
# ============================================

# Boolean attributes - True renders, False omits
<input type="checkbox" disabled={is_active} />
<button disabled={not is_active}>Disabled when inactive</button>
<input type="text" readonly={count == 0} />

# Dynamic class with list and dict
<div class={["card", "shadow", {"active": is_active, "highlighted": count > 5}]}>
    Dynamic class
</div>

# Dynamic style with dict
<p style={{"color": user.get("color", "black"), "font-size": f"{count + 12}px"}}>
    Dynamic style
</p>

# Combined - class list with conditional + boolean attr
<button
    class={["btn", {"btn-primary": user.get("role") == "admin", "btn-secondary": user.get("role") != "admin"}]}
    disabled={count == 0}>
    Submit
</button>

# ============================================
# CONTEXT MANAGERS (with statement)
# ============================================

# Simple with
with open("/tmp/test.txt") as f:
    content = f.read()
    <pre>{content}</pre>
end

# Nested with statements
with user.get('lock', nullcontext()):
    <div class="critical-section">
        <span>Protected content</span>
    </div>
end

# ============================================
# TRY/EXCEPT PATTERNS
# ============================================

# Simple try/except
try:
    <span>{user['missing_key']}</span>
except KeyError:
    <span class="error">Key not found</span>
end

# Multiple exception types
try:
    value = int(user.get('number', 'invalid'))
    <span>Number: {value}</span>
except ValueError as e:
    <span class="error">Invalid number: {e}</span>
except TypeError as e:
    <span class="error">Type error: {e}</span>
end

# try/except/else/finally
try:
    result = user['required']
except KeyError:
    <span class="warning">Using default</span>
    result = "default"
else:
    <span class="info">Found value</span>
finally:
    <span class="result"
          style={True}
          >
          Result: {result}
    </span>
end

# ============================================
# RECURSIVE FUNCTIONS
# ============================================

# Recursive tree rendering
def render_tree(node: dict, depth: int = 0):
    <div class="tree-node" style="margin-left: {depth * 20}px">
        <span class="label">{node.get('label', 'Node')}</span>
        if node.get('children'):
            <div class="children">
                for child in node['children']:
                    render_tree(child, depth + 1)
                end
            </div>
        end
    </div>
end

# Call recursive function
render_tree(user.get('tree', {'label': 'Root'}))

# ============================================
# FRAGMENT DECORATOR
# ============================================

@fragment
def TreeNode(n: dict, depth: int = 0):
    <div class="tree-node" style="margin-left: {depth * 20}px">
        <span>{n.get('label', 'Node')}</span>
    </div>
end

# ============================================
# SLOT PATTERN
# ============================================

# Slot placeholder for children content
<div class="card">
    <div class="card-header">
        <h2>{user['name']}</h2>
    </div>
    <div class="card-body">
        {...}
    </div>
</div>

# Final element
<footer>
    <p>Generated by Hyper</p>
</footer>
