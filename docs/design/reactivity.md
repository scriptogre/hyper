# Reactive Templates

> **Status**: Very Early Draft

Reactive templates enable real-time interactivity without JavaScript frameworks. The server manages state. The client applies minimal HTML updates over WebSockets.

---

## Overview

**Current behavior**: Templates return strings.

```python
from components import Counter

html = Counter(count=0)  # Returns full HTML string
```

**Reactive behavior**: Templates maintain state and push updates.

```hyper
# Counter.hyper
count: int = 0

def increment():
    global count
    count += 1

def decrement():
    global count
    count -= 1

---

<div>
    <h1>Count: {count}</h1>
    <button {on:'click'}={increment}>+</button>
    <button {on:'click'}={decrement}>-</button>
</div>
```

User clicks button. Server increments count. Client receives minimal HTML patch.

**Key principle**: Write Python. Get real-time UI.

---

## Diff-Aware Rendering

Templates track static vs dynamic regions. Only changed content is sent.

### How It Works

**Compilation phase** (Rust transpiler):

The transpiler analyzes the template and identifies static and dynamic regions.

```hyper
name: str

---

<h1>Hello {name}</h1>
```

**Generated structure**:

```python
from hyper.runtime import Template, Static, Dynamic

def Greeting(name: str) -> Template:
    return Template([
        Static("<h1>Hello "),
        Dynamic(0, lambda ctx: ctx['name']),
        Static("</h1>")
    ])
```

**Runtime diffing** (Python):

```python
template = Greeting(name="Alice")
html1 = template.render()  # "<h1>Hello Alice</h1>"

template.update(name="Bob")
diff = template.compute_diff()  # Only "Bob", not full HTML
```

**Client application**:

The client receives a minimal patch and updates the DOM using morphing.

```javascript
// Auto-generated by compiler, injected in <script>
websocket.onmessage = (event) => {
  const patch = JSON.parse(event.data);
  morphdom(document.getElementById(patch.id), patch.html);
};
```

### Diffing Algorithm

**Implementation**: Written in Rust for performance.

The algorithm compares previous and current template state:

1. Walk the template structure
2. Compare each dynamic region's value
3. If changed, mark for update
4. Generate minimal patch with changed regions only

**Output format**:

```json
{
  "id": "counter-123",
  "patches": [
    {"path": [0, 1], "html": "<h1>Count: 1</h1>"}
  ]
}
```

The `path` identifies which element to update. The `html` is the new content.

---

## Event Handling

Events trigger server-side Python functions.

### Syntax

```hyper
<button {on:'click'}={handler_function}>
```

The `{on:'event'}` syntax maps to event listeners. The compiler generates:

1. A unique ID for the element
2. JavaScript to send event to server
3. Server-side event dispatcher

### Compilation

**Template**:

```hyper
count: int = 0

def increment():
    global count
    count += 1

---

<button {on:'click'}={increment}>Add</button>
```

**Generated HTML**:

```html
<button id="btn-a1b2c3" data-event-click="increment">Add</button>

<script>
  document.getElementById('btn-a1b2c3').addEventListener('click', (e) => {
    window.__hyper_ws.send(JSON.stringify({
      event: 'increment',
      target: 'btn-a1b2c3'
    }));
  });
</script>
```

**No external library required**. The compiler generates all JavaScript inline.

### Supported Events

All standard DOM events:

- `click`, `dblclick`
- `submit`, `change`, `input`
- `keydown`, `keyup`, `keypress`
- `mouseenter`, `mouseleave`, `mouseover`
- `focus`, `blur`

Custom events via `{on:'custom-event'}`.

### Event Arguments

Access event data in handlers:

```hyper
from hyper import Event

def handle_input(event: Event):
    value = event.target.value
    print(f"User typed: {value}")

---

<input {on:'input'}={handle_input} />
```

The server receives serialized event data over WebSocket.

---

## State Management

State lives server-side. Each connected client has isolated state.

### Global State

```hyper
count: int = 0

def increment():
    global count
    count += 1
```

State persists across events for this client session.

### Component-Level State

```hyper
class Counter:
    def __init__(self, initial: int = 0):
        self.count = initial

    def increment(self):
        self.count += 1

counter = Counter()

---

<div>
    <h1>{counter.count}</h1>
    <button {on:'click'}={counter.increment}>+</button>
</div>
```

Use classes for encapsulated state.

### Session Storage

State is stored per WebSocket connection:

```python
# Runtime implementation
class Session:
    def __init__(self, template_fn, initial_props):
        self.template_fn = template_fn
        self.props = initial_props
        self.state = {}

    def handle_event(self, event_name, event_data):
        handler = self.state['handlers'][event_name]
        handler(event_data)
        return self.compute_diff()
```

Sessions live in memory. For persistence, integrate with Redis or database.

---

## Auto-Generated Scripts

**No client library installation**. The compiler injects all required JavaScript.

### WebSocket Setup

```html
<script>
  window.__hyper_ws = new WebSocket('ws://localhost:8000/ws');

  __hyper_ws.onmessage = (event) => {
    const data = JSON.parse(event.data);

    if (data.type === 'patch') {
      applyPatch(data);
    }
  };

  function applyPatch(patch) {
    const el = document.getElementById(patch.id);
    if (el) {
      morphdom(el, patch.html);
    }
  }
</script>
```

### DOM Morphing

The compiler embeds a minimal morphing algorithm:

```javascript
function morphdom(from, toHTML) {
  const temp = document.createElement('div');
  temp.innerHTML = toHTML;
  const to = temp.firstElementChild;

  // Efficient DOM diffing
  // Preserves focus, selection, event listeners
  // Only updates changed attributes and children
}
```

**Size**: ~2KB minified. Embedded inline per reactive template.

### Event Dispatching

```javascript
function dispatch(event, target, handler) {
  __hyper_ws.send(JSON.stringify({
    event: handler,
    target: target,
    data: serializeEvent(event)
  }));
}

function serializeEvent(event) {
  return {
    type: event.type,
    target: {
      value: event.target.value,
      checked: event.target.checked
    },
    key: event.key,
    // ... other relevant properties
  };
}
```

All generated automatically. Developers write zero JavaScript.

---

## Framework Integration

### FastAPI

```python
from fastapi import FastAPI, WebSocket
from hyper.runtime import ReactiveSession
from components import Counter

app = FastAPI()

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()

    session = ReactiveSession(
        template=Counter,
        props={'count': 0}
    )

    # Send initial render
    await websocket.send_text(session.render())

    # Handle events
    async for message in websocket:
        data = json.loads(message)
        patch = session.handle_event(data['event'], data.get('data'))
        await websocket.send_json(patch)

@app.get("/")
def index():
    return HTMLResponse(Counter(count=0))  # Initial page load
```

### Django Channels

```python
from channels.generic.websocket import AsyncWebsocketConsumer
from hyper.runtime import ReactiveSession
from components import Counter

class CounterConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        await self.accept()
        self.session = ReactiveSession(Counter, {'count': 0})
        await self.send(text_data=self.session.render())

    async def receive(self, text_data):
        data = json.loads(text_data)
        patch = self.session.handle_event(data['event'], data.get('data'))
        await self.send(text_data=json.dumps(patch))
```

---

## Scaling Considerations

### Session Distribution

Use Redis for distributed sessions:

```python
from hyper.runtime import ReactiveSession
from redis import Redis

redis = Redis()

class DistributedSession(ReactiveSession):
    def __init__(self, session_id, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.session_id = session_id

    def save_state(self):
        redis.set(f"session:{self.session_id}", pickle.dumps(self.state))

    def load_state(self):
        data = redis.get(f"session:{self.session_id}")
        if data:
            self.state = pickle.loads(data)
```

### Pub/Sub for Broadcasts

Share updates across connected clients:

```python
redis_pubsub = redis.pubsub()

# Publisher
def broadcast_update(channel, patch):
    redis.publish(channel, json.dumps(patch))

# Subscriber (in WebSocket handler)
async def listen_for_updates():
    async for message in redis_pubsub.listen():
        if message['type'] == 'message':
            await websocket.send(message['data'])
```

### Connection Limits

Optimize for high connection counts:

- Use async/await for non-blocking I/O
- Pool WebSocket connections
- Implement heartbeat/ping for connection health
- Set idle timeouts for inactive sessions

---

## Comparison with LiveView

| Feature | Phoenix LiveView | Hyper Reactive |
|---------|-----------------|----------------|
| Language | Elixir | Python |
| State location | Server | Server |
| Transport | WebSocket | WebSocket |
| Diffing | Runtime (Elixir) | Runtime (Rust) |
| Client code | None | Auto-generated |
| Framework | Phoenix only | Any Python framework |

**Key difference**: Hyper generates inline JavaScript. LiveView uses a standalone client library.

**Advantage**: Zero external dependencies. Templates are self-contained.

**Trade-off**: Slightly larger initial HTML (~2KB per reactive component).

---

## Implementation Roadmap

### Phase 1: Diff Engine (Rust)

- [ ] Template structure representation
- [ ] Static vs dynamic region analysis during compilation
- [ ] Diff algorithm in Rust
- [ ] Python bindings via PyO3

### Phase 2: Code Generation

- [ ] Generate `Template` objects instead of strings
- [ ] Emit `<script>` tags with WebSocket client
- [ ] Emit event dispatcher JavaScript
- [ ] Generate unique IDs for interactive elements

### Phase 3: Runtime (Python)

- [ ] `ReactiveSession` class for state management
- [ ] Event handler registry and dispatch
- [ ] WebSocket integration helpers
- [ ] Diff computation API

### Phase 4: Framework Integration

- [ ] FastAPI example and helpers
- [ ] Django Channels example
- [ ] Flask-SocketIO example
- [ ] Documentation and guides

### Phase 5: Optimizations

- [ ] JavaScript minification
- [ ] Compression of patches
- [ ] Batch multiple updates
- [ ] Debounce rapid events

---

## Open Questions

### Syntax

Current proposal uses `{on:'event'}`:

```hyper
<button {on:'click'}={handler}>Click</button>
```

Alternatives:

```hyper
<button @click={handler}>Click</button>       # Vue-style
<button on:click={handler}>Click</button>     # Svelte-style
<button onclick={handler}>Click</button>      # HTML-style
```

**Decision needed**: Which syntax feels most natural for Python developers?

### State Persistence

Should state automatically persist to database/Redis?

```hyper
# Option 1: Manual
session.save_to_redis()

# Option 2: Automatic with decorator
@persistent
count: int = 0
```

**Decision needed**: Explicit or implicit persistence?

### Multi-Client Sync

Should multiple browser tabs for same user share state?

```python
# Same user, two tabs
# Tab 1: clicks increment
# Tab 2: sees update automatically?
```

**Decision needed**: Isolated sessions or synchronized state?

### Progressive Enhancement

Should reactive templates work without JavaScript?

```hyper
# Fallback to form submission when JS disabled
<form method="POST" action="/increment">
    <button type="submit">+</button>
</form>
```

**Decision needed**: Require JavaScript or provide fallback?

---

**See Also**:
- [Templates](templates.md) - Template syntax
- [Template Implementation](../implementation/templates.md) - Transpiler details
- [SSR](ssr.md) - Server-side rendering
